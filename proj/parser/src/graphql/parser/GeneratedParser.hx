package graphql.parser;

/* GENERATED BY gen_parser.rb -- DO NOT EDIT!!! */
/* GENERATED BY gen_parser.rb -- DO NOT EDIT!!! */
/* GENERATED BY gen_parser.rb -- DO NOT EDIT!!! */
/* GENERATED BY gen_parser.rb -- DO NOT EDIT!!! */
/* */
/* based on: https://raw.githubusercontent.com/graphql/graphql-js/v14.3.0/src/language/parser.js */
/* */

import graphql.ASTDefs;
import graphql.parser.GeneratedLexer;

// Move this to ASTDefs?
typedef SomeFragmentNode = BaseNode; // FragmentSpreadNode | InlineFragmentNode

typedef TODO = { };
typedef GraphQLError = { };

typedef Lexer = GeneratedLexer<ParseOptions>;

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow strict
 */

// import inspect from '../jsutils/inspect';
// import defineToJSON from '../jsutils/defineToJSON';
/* import BR_L Source } from './source';
// import BR_L type GraphQLError, syntaxError } from '../error';
import BR_L
  type Lexer,
  type TokenKindEnum,
  TokenKind,
  getTokenDesc,
  createLexer,
} from './lexer';
import BR_L
  type Location,
  type Token,
  type NameNode,
  type VariableNode,
  type DocumentNode,
  type DefinitionNode,
  type ExecutableDefinitionNode,
  type OperationDefinitionNode,
  type OperationTypeNode,
  type VariableDefinitionNode,
  type SelectionSetNode,
  type SelectionNode,
  type FieldNode,
  type ArgumentNode,
  type FragmentSpreadNode,
  type InlineFragmentNode,
  type FragmentDefinitionNode,
  type ValueNode,
  type StringValueNode,
  type ListValueNode,
  type ObjectValueNode,
  type ObjectFieldNode,
  type DirectiveNode,
  type TypeNode,
  type NamedTypeNode,
  type ListTypeNode,
  type NonNullTypeNode,
  type TypeSystemDefinitionNode,
  type SchemaDefinitionNode,
  type OperationTypeDefinitionNode,
  type ScalarTypeDefinitionNode,
  type ObjectTypeDefinitionNode,
  type FieldDefinitionNode,
  type InputValueDefinitionNode,
  type InterfaceTypeDefinitionNode,
  type UnionTypeDefinitionNode,
  type EnumTypeDefinitionNode,
  type EnumValueDefinitionNode,
  type InputObjectTypeDefinitionNode,
  type DirectiveDefinitionNode,
  type TypeSystemExtensionNode,
  type SchemaExtensionNode,
  type ScalarTypeExtensionNode,
  type ObjectTypeExtensionNode,
  type InterfaceTypeExtensionNode,
  type UnionTypeExtensionNode,
  type EnumTypeExtensionNode,
  type InputObjectTypeExtensionNode,
} from './ast';

// import BR_L Kind } from './kinds';
// import BR_L DirectiveLocation } from './directiveLocation'; */

/**
 * Configuration options to control parser behavior
 */
typedef /* export type */ ParseOptions = {
  /**
   * By default, the parser creates AST nodes that know the location
   * in the source that they correspond to. This configuration flag
   * disables that behavior for performance or testing.
   */
  ?noLocation /* opt */ :Bool,

  /**
   * If enabled, the parser will parse empty fields sets in the Schema
   * Definition Language. Otherwise, the parser will follow the current
   * specification.
   *
   * This option is provided to ease adoption of the final SDL specification
   * and will be removed in v16.
   */
  ?allowLegacySDLEmptyFields /* opt */ :Bool,

  /**
   * If enabled, the parser will parse implemented interfaces with no '&'
   * character between each interface. Otherwise, the parser will follow the
   * current specification.
   *
   * This option is provided to ease adoption of the final SDL specification
   * and will be removed in v16.
   */
  ?allowLegacySDLImplementsInterfaces /* opt */ :Bool,

  /**
   * EXPERIMENTAL:
   *
   * If enabled, the parser will understand and parse variable definitions
   * contained in a fragment definition. They'll be represented in the
   * 'variableDefinitions' field of the FragmentDefinitionNode.
   *
   * The syntax is identical to normal, query-defined variables. For example:
   *
   *   fragment A($var: Boolean = false) on T  {
   *     ...
   *   }
   *
   * Note: this feature is experimental and may change or be removed in the
   * future.
   */
  ?experimentalFragmentVariables /* opt */ :Bool,
};

/**
 * Given a GraphQL source, parses it into a Document.
 * Throws GraphQLError if a syntax error is encountered.
 */


/**/
/**/
/**/
class GeneratedParser {


/* Removed top-level parse() function */
 public function new() { }

/**
 * Given a string containing a GraphQL value (ex. '[42]'), parse the AST for
 * that value.
 * Throws GraphQLError if a syntax error is encountered.
 *
 * This is useful within tools that operate upon GraphQL Values directly and
 * in isolation of complete GraphQL documents.
 *
 * Consider providing the results to the utility function: valueFromAST().
 */
/* Removed parseValue() and parseType() */

/**
 * Converts a name lex token into a name parse node.
 */
private function parseName(lexer: Lexer): NameNode {
  var token = expectToken(lexer, TokenKind.NAME);
  return {
    kind: Kind.NAME,
    value: ((token.value:Dynamic):String),
    loc: loc(lexer, token),
  };
}

// Implements the parsing rules in the Document section.

/**
 * Document : Definition+
 */
public function parseDocument(lexer: Lexer): DocumentNode {
  var start = lexer.token;
  return {
    kind: Kind.DOCUMENT,
    definitions: many(lexer, TokenKind.SOF, parseDefinition, TokenKind.EOF),
    loc: loc(lexer, start),
  };
}

/**
 * Definition :
 *   - ExecutableDefinition
 *   - TypeSystemDefinition
 *   - TypeSystemExtension
 */
private function parseDefinition(lexer: Lexer): DefinitionNode {
  if (peek(lexer, TokenKind.NAME)) {
    switch (lexer.token.value) {
      case 'query' | /*CFT*/ 'mutation' | /*CFT*/ 'subscription' | /*CFT*/ 'fragment':
        return parseExecutableDefinition(lexer);
      case 'schema' | /*CFT*/ 'scalar' | /*CFT*/ 'type' | /*CFT*/ 'interface' | /*CFT*/ 'union' | /*CFT*/ 'enum' | /*CFT*/ 'input' | /*CFT*/ 'directive':
        return parseTypeSystemDefinition(lexer);
      case 'extend':
        return parseTypeSystemExtension(lexer);
    }
  } else if (peek(lexer, TokenKind.BRACE_L)) {
    return parseExecutableDefinition(lexer);
  } else if (peekDescription(lexer)) {
    return parseTypeSystemDefinition(lexer);
  }

  throw unexpected(lexer);
}

/**
 * ExecutableDefinition :
 *   - OperationDefinition
 *   - FragmentDefinition
 */
private function parseExecutableDefinition(lexer: Lexer): ExecutableDefinitionNode {
  if (peek(lexer, TokenKind.NAME)) {
    switch (lexer.token.value) {
      case 'query' | /*CFT*/ 'mutation' | /*CFT*/ 'subscription':
        return parseOperationDefinition(lexer);

      case 'fragment':
        return parseFragmentDefinition(lexer);
    }
  } else if (peek(lexer, TokenKind.BRACE_L)) {
    return parseOperationDefinition(lexer);
  }

  throw unexpected(lexer);
}

// Implements the parsing rules in the Operations section.

/**
 * OperationDefinition :
 *  - SelectionSet
 *  - OperationType Name? VariableDefinitions? Directives? SelectionSet
 */
private function parseOperationDefinition(lexer: Lexer): OperationDefinitionNode {
  var start = lexer.token;
  if (peek(lexer, TokenKind.BRACE_L)) {
    return {
      kind: Kind.OPERATION_DEFINITION,
      operation: 'query',
      name: null/* undefined */,
      variableDefinitions: [],
      directives: [],
      selectionSet: parseSelectionSet(lexer),
      loc: loc(lexer, start),
    };
  }
  var operation = parseOperationType(lexer);
  var name=null /* INIT */;
  if (peek(lexer, TokenKind.NAME)) {
    name = parseName(lexer);
  }
  return {
    kind: Kind.OPERATION_DEFINITION,
    operation:operation, /* ESIOK: stupid inferred key name */
    name:name, /* ESIOK: stupid inferred key name */
    variableDefinitions: parseVariableDefinitions(lexer),
    directives: parseDirectives(lexer, false),
    selectionSet: parseSelectionSet(lexer),
    loc: loc(lexer, start),
  };
}

/**
 * OperationType : one of query mutation subscription
 */
private function parseOperationType(lexer: Lexer): OperationTypeNode {
  var operationToken = expectToken(lexer, TokenKind.NAME);
  switch (operationToken.value) {
    case 'query':
      return 'query';
    case 'mutation':
      return 'mutation';
    case 'subscription':
      return 'subscription';
  }

  throw unexpected(lexer, operationToken);
}

/**
 * VariableDefinitions : ( VariableDefinition+ )
 */
private function parseVariableDefinitions(
  lexer: Lexer): Array<VariableDefinitionNode> 
{
  return peek(lexer, TokenKind.PAREN_L)
    ? many(lexer, TokenKind.PAREN_L, parseVariableDefinition, TokenKind.PAREN_R)
    : [];
}

/**
 * VariableDefinition : Variable : Type DefaultValue? Directives[Const]?
 */
private function parseVariableDefinition(lexer: Lexer): VariableDefinitionNode {
  var start = lexer.token;
  return {
    kind: Kind.VARIABLE_DEFINITION,
    variable: parseVariable(lexer),
    type: { expectToken(lexer, TokenKind.COLON) ;  parseTypeReference(lexer) ; } /* WTH (,) block */,
    defaultValue: expectOptionalToken(lexer, TokenKind.EQUALS)
      ? parseValueLiteral(lexer, true)
      : null/* undefined */,
    directives: parseDirectives(lexer, true),
    loc: loc(lexer, start),
  };
}

/**
 * Variable : $ Name
 */
private function parseVariable(lexer: Lexer): VariableNode {
  var start = lexer.token;
  expectToken(lexer, TokenKind.DOLLAR);
  return {
    kind: Kind.VARIABLE,
    name: parseName(lexer),
    loc: loc(lexer, start),
  };
}

/**
 * SelectionSet : { Selection+ }
 */
private function parseSelectionSet(lexer: Lexer): SelectionSetNode {
  var start = lexer.token;
  return {
    kind: Kind.SELECTION_SET,
    selections: many(
      lexer,
      TokenKind.BRACE_L,
      parseSelection,
      TokenKind.BRACE_R),
    loc: loc(lexer, start),
  };
}

/**
 * Selection :
 *   - Field
 *   - FragmentSpread
 *   - InlineFragment
 */
private function parseSelection(lexer: Lexer): SelectionNode {
  return peek(lexer, TokenKind.SPREAD)
    ? parseFragment(lexer)
    : parseField(lexer);
}

/**
 * Field : Alias? Name Arguments? Directives? SelectionSet?
 *
 * Alias : Name :
 */
private function parseField(lexer: Lexer): FieldNode {
  var start = lexer.token;

  var nameOrAlias = parseName(lexer);
  var alias=null /* INIT */;
  var name=null /* INIT */;
  if (expectOptionalToken(lexer, TokenKind.COLON)) {
    alias = nameOrAlias;
    name = parseName(lexer);
  } else {
    name = nameOrAlias;
  }

  return {
    kind: Kind.FIELD,
    alias:alias, /* ESIOK: stupid inferred key name */
    name:name, /* ESIOK: stupid inferred key name */
    arguments: parseArguments(lexer, false),
    directives: parseDirectives(lexer, false),
    selectionSet: peek(lexer, TokenKind.BRACE_L)
      ? parseSelectionSet(lexer)
      : null/* undefined */,
    loc: loc(lexer, start),
  };
}

/**
 * Arguments[Const] : ( Argument[?Const]+ )
 */
private function parseArguments(
  lexer: Lexer,
  isConst:Bool): Array<ArgumentNode> 
{
  var item = isConst ? parseConstArgument : parseArgument;
  return peek(lexer, TokenKind.PAREN_L)
    ? many(lexer, TokenKind.PAREN_L, item, TokenKind.PAREN_R)
    : [];
}

/**
 * Argument[Const] : Name : Value[?Const]
 */
private function parseArgument(lexer: Lexer): ArgumentNode {
  var start = lexer.token;
  var name = parseName(lexer);

  expectToken(lexer, TokenKind.COLON);
  return {
    kind: Kind.ARGUMENT,
    name:name, /* ESIOK: stupid inferred key name */
    value: parseValueLiteral(lexer, false),
    loc: loc(lexer, start),
  };
}

private function parseConstArgument(lexer: Lexer): ArgumentNode {
  var start = lexer.token;
  return {
    kind: Kind.ARGUMENT,
    name: parseName(lexer),
    value: { expectToken(lexer, TokenKind.COLON) ;  parseConstValue(lexer) ; } /* WTH (,) block */,
    loc: loc(lexer, start),
  };
}

// Implements the parsing rules in the Fragments section.

/**
 * Corresponds to both FragmentSpread and InlineFragment in the spec.
 *
 * FragmentSpread : ... FragmentName Directives?
 *
 * InlineFragment : ... TypeCondition? Directives? SelectionSet
 */
private function parseFragment(
  lexer: Lexer): SomeFragmentNode 
{
  var start = lexer.token;
  expectToken(lexer, TokenKind.SPREAD);

  var hasTypeCondition = expectOptionalKeyword(lexer, 'on');
  if (!hasTypeCondition && peek(lexer, TokenKind.NAME)) {
    return /* CSMT */ cast {
      kind: Kind.FRAGMENT_SPREAD,
      name: parseFragmentName(lexer),
      directives: parseDirectives(lexer, false),
      loc: loc(lexer, start),
    };
  }
  return /* CSMT */ cast {
    kind: Kind.INLINE_FRAGMENT,
    typeCondition: hasTypeCondition ? parseNamedType(lexer) : null/* undefined */,
    directives: parseDirectives(lexer, false),
    selectionSet: parseSelectionSet(lexer),
    loc: loc(lexer, start),
  };
}

/**
 * FragmentDefinition :
 *   - fragment FragmentName on TypeCondition Directives? SelectionSet
 *
 * TypeCondition : NamedType
 */
private function parseFragmentDefinition(lexer: Lexer): FragmentDefinitionNode {
  var start = lexer.token;
  expectKeyword(lexer, 'fragment');
  // Experimental support for defining variables within fragments changes
  // the grammar of FragmentDefinition:
  //   - fragment FragmentName VariableDefinitions? on TypeCondition Directives? SelectionSet
  if (lexer.options.experimentalFragmentVariables) {
    return /* CSMT */ cast {
      kind: Kind.FRAGMENT_DEFINITION,
      name: parseFragmentName(lexer),
      variableDefinitions: parseVariableDefinitions(lexer),
      typeCondition: { expectKeyword(lexer, 'on') ;  parseNamedType(lexer) ; } /* WTH (,) block */,
      directives: parseDirectives(lexer, false),
      selectionSet: parseSelectionSet(lexer),
      loc: loc(lexer, start),
    };
  }
  return {
    kind: Kind.FRAGMENT_DEFINITION,
    name: parseFragmentName(lexer),
    typeCondition: { expectKeyword(lexer, 'on') ;  parseNamedType(lexer) ; } /* WTH (,) block */,
    directives: parseDirectives(lexer, false),
    selectionSet: parseSelectionSet(lexer),
    loc: loc(lexer, start),
  };
}

/**
 * FragmentName : Name but not 'on'
 */
private function parseFragmentName(lexer: Lexer): NameNode {
  if (lexer.token.value == 'on') {
    throw unexpected(lexer);
  }
  return parseName(lexer);
}

// Implements the parsing rules in the Values section.

/**
 * Value[Const] :
 *   - [~Const] Variable
 *   - IntValue
 *   - FloatValue
 *   - StringValue
 *   - BooleanValue
 *   - NullValue
 *   - EnumValue
 *   - ListValue[?Const]
 *   - ObjectValue[?Const]
 *
 * BooleanValue : one of 'true' 'false'
 *
 * NullValue : 'null'
 *
 * EnumValue : Name but not 'true', 'false' or 'null'
 */
private function parseValueLiteral(lexer: Lexer, isConst:Bool): ValueNode {
  var token = lexer.token;
  switch (token.kind) {
    case TokenKind.BRACKET_L:
      return parseList(lexer, isConst);
    case TokenKind.BRACE_L:
      return parseObject(lexer, isConst);
    case TokenKind.INT:
      lexer.advance();
      return /* CSMT */ cast {
        kind: Kind.INT,
        value: ((token.value:Dynamic):String),
        loc: loc(lexer, token),
      };
    case TokenKind.FLOAT:
      lexer.advance();
      return /* CSMT */ cast {
        kind: Kind.FLOAT,
        value: ((token.value:Dynamic):String),
        loc: loc(lexer, token),
      };
    case TokenKind.STRING | /*CFT*/ TokenKind.BLOCK_STRING:
      return parseStringLiteral(lexer);
    case TokenKind.NAME:
      if (token.value == 'true' || token.value == 'false') {
        lexer.advance();
        return /* CSMT */ cast {
          kind: Kind.BOOLEAN,
          value: token.value == 'true',
          loc: loc(lexer, token),
        };
      } else if (token.value == 'null') {
        lexer.advance();
        return /* CSMT */ cast {
          kind: Kind.NULL,
          loc: loc(lexer, token),
        };
      }
      lexer.advance();
      return /* CSMT */ cast {
        kind: Kind.ENUM,
        value: ((token.value:Dynamic):String),
        loc: loc(lexer, token),
      };
    case TokenKind.DOLLAR:
      if (!isConst) {
        return parseVariable(lexer);
      }
    default: /* was break, fall through to throw */

  }
  throw unexpected(lexer);
}

private function parseStringLiteral(lexer: Lexer): StringValueNode {
  var token = lexer.token;
  lexer.advance();
  return {
    kind: Kind.STRING,
    value: ((token.value:Dynamic):String),
    block: token.kind == TokenKind.BLOCK_STRING,
    loc: loc(lexer, token),
  };
}

public function parseConstValue(lexer: Lexer): ValueNode {
  return parseValueLiteral(lexer, true);
}

private function parseValueValue(lexer: Lexer): ValueNode {
  return parseValueLiteral(lexer, false);
}

/**
 * ListValue[Const] :
 *   - [ ]
 *   - [ Value[?Const]+ ]
 */
private function parseList(lexer: Lexer, isConst:Bool): ListValueNode {
  var start = lexer.token;
  var item = isConst ? parseConstValue : parseValueValue;
  return {
    kind: Kind.LIST,
    values: any(lexer, TokenKind.BRACKET_L, item, TokenKind.BRACKET_R),
    loc: loc(lexer, start),
  };
}

/**
 * ObjectValue[Const] :
 *   - { }
 *   - { ObjectField[?Const]+ }
 */
private function parseObject(lexer: Lexer, isConst:Bool): ObjectValueNode {
  var start = lexer.token;
  var item = function(?lxr) return parseObjectField(lexer, isConst);
  return {
    kind: Kind.OBJECT,
    fields: any(lexer, TokenKind.BRACE_L, item, TokenKind.BRACE_R),
    loc: loc(lexer, start),
  };
}

/**
 * ObjectField[Const] : Name : Value[?Const]
 */
private function parseObjectField(lexer: Lexer, isConst:Bool): ObjectFieldNode {
  var start = lexer.token;
  var name = parseName(lexer);
  expectToken(lexer, TokenKind.COLON);

  return {
    kind: Kind.OBJECT_FIELD,
    name:name, /* ESIOK: stupid inferred key name */
    value: parseValueLiteral(lexer, isConst),
    loc: loc(lexer, start),
  };
}

// Implements the parsing rules in the Directives section.

/**
 * Directives[Const] : Directive[?Const]+
 */
private function parseDirectives(
  lexer: Lexer,
  isConst:Bool): Array<DirectiveNode> 
{
  var directives = [];
  while (peek(lexer, TokenKind.AT)) {
    directives.push(parseDirective(lexer, isConst));
  }
  return directives;
}

/**
 * Directive[Const] : @ Name Arguments[?Const]?
 */
private function parseDirective(lexer: Lexer, isConst:Bool): DirectiveNode {
  var start = lexer.token;
  expectToken(lexer, TokenKind.AT);
  return {
    kind: Kind.DIRECTIVE,
    name: parseName(lexer),
    arguments: parseArguments(lexer, isConst),
    loc: loc(lexer, start),
  };
}

// Implements the parsing rules in the Types section.

/**
 * Type :
 *   - NamedType
 *   - ListType
 *   - NonNullType
 */
public function parseTypeReference(lexer: Lexer): TypeNode {
  var start = lexer.token;
  var type=null /* INIT */;
  if (expectOptionalToken(lexer, TokenKind.BRACKET_L)) {
    type = parseTypeReference(lexer);
    expectToken(lexer, TokenKind.BRACKET_R);
    type = /* CSMT2 */ ( cast {
      kind: Kind.LIST_TYPE,
      type:type, /* ESIOK: stupid inferred key name */
      loc: loc(lexer, start),
    }/* : ListTypeNode */);
  } else {
    type = /* */ cast parseNamedType(lexer);
  }
  if (expectOptionalToken(lexer, TokenKind.BANG)) {
    return /* CSMT2 */ ( cast {
      kind: Kind.NON_NULL_TYPE,
      type:type, /* ESIOK: stupid inferred key name */
      loc: loc(lexer, start),
    }/* : NonNullTypeNode */);
  }
  return type;
}

/**
 * NamedType : Name
 */
public function parseNamedType(lexer: Lexer): NamedTypeNode {
  var start = lexer.token;
  return {
    kind: Kind.NAMED_TYPE,
    name: parseName(lexer),
    loc: loc(lexer, start),
  };
}

// Implements the parsing rules in the Type Definition section.

/**
 * TypeSystemDefinition :
 *   - SchemaDefinition
 *   - TypeDefinition
 *   - DirectiveDefinition
 *
 * TypeDefinition :
 *   - ScalarTypeDefinition
 *   - ObjectTypeDefinition
 *   - InterfaceTypeDefinition
 *   - UnionTypeDefinition
 *   - EnumTypeDefinition
 *   - InputObjectTypeDefinition
 */
private function parseTypeSystemDefinition(lexer: Lexer): TypeSystemDefinitionNode {
  // Many definitions begin with a description and require a lookahead.
  var keywordToken = peekDescription(lexer) ? lexer.lookahead() : lexer.token;

  if (keywordToken.kind == TokenKind.NAME) {
    switch (keywordToken.value) {
      case 'schema':
        return parseSchemaDefinition(lexer);
      case 'scalar':
        return parseScalarTypeDefinition(lexer);
      case 'type':
        return parseObjectTypeDefinition(lexer);
      case 'interface':
        return parseInterfaceTypeDefinition(lexer);
      case 'union':
        return parseUnionTypeDefinition(lexer);
      case 'enum':
        return parseEnumTypeDefinition(lexer);
      case 'input':
        return parseInputObjectTypeDefinition(lexer);
      case 'directive':
        return parseDirectiveDefinition(lexer);
    }
  }

  throw unexpected(lexer, keywordToken);
}

private function peekDescription(lexer: Lexer):Bool {
  return peek(lexer, TokenKind.STRING) || peek(lexer, TokenKind.BLOCK_STRING);
}

/**
 * Description : StringValue
 */
private function parseDescription(lexer: Lexer): Null<StringValueNode> {
  if (!(peekDescription(lexer))) return null; {
    return parseStringLiteral(lexer);
  }
}

/**
 * SchemaDefinition : schema Directives[Const]? { OperationTypeDefinition+ }
 */
private function parseSchemaDefinition(lexer: Lexer): SchemaDefinitionNode {
  var start = lexer.token;
  expectKeyword(lexer, 'schema');
  var directives = parseDirectives(lexer, true);
  var operationTypes = many(
    lexer,
    TokenKind.BRACE_L,
    parseOperationTypeDefinition,
    TokenKind.BRACE_R);
  return {
    kind: Kind.SCHEMA_DEFINITION,
    directives:directives, /* ESIOK: stupid inferred key name */
    operationTypes:operationTypes, /* ESIOK: stupid inferred key name */
    loc: loc(lexer, start),
  };
}

/**
 * OperationTypeDefinition : OperationType : NamedType
 */
private function parseOperationTypeDefinition(
  lexer: Lexer): OperationTypeDefinitionNode 
{
  var start = lexer.token;
  var operation = parseOperationType(lexer);
  expectToken(lexer, TokenKind.COLON);
  var type = parseNamedType(lexer);
  return {
    kind: Kind.OPERATION_TYPE_DEFINITION,
    operation:operation, /* ESIOK: stupid inferred key name */
    type:type, /* ESIOK: stupid inferred key name */
    loc: loc(lexer, start),
  };
}

/**
 * ScalarTypeDefinition : Description? scalar Name Directives[Const]?
 */
private function parseScalarTypeDefinition(lexer: Lexer): ScalarTypeDefinitionNode {
  var start = lexer.token;
  var description = parseDescription(lexer);
  expectKeyword(lexer, 'scalar');
  var name = parseName(lexer);
  var directives = parseDirectives(lexer, true);
  return {
    kind: Kind.SCALAR_TYPE_DEFINITION,
    description:description, /* ESIOK: stupid inferred key name */
    name:name, /* ESIOK: stupid inferred key name */
    directives:directives, /* ESIOK: stupid inferred key name */
    loc: loc(lexer, start),
  };
}

/**
 * ObjectTypeDefinition :
 *   Description?
 *   type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition?
 */
private function parseObjectTypeDefinition(lexer: Lexer): ObjectTypeDefinitionNode {
  var start = lexer.token;
  var description = parseDescription(lexer);
  expectKeyword(lexer, 'type');
  var name = parseName(lexer);
  var interfaces = parseImplementsInterfaces(lexer);
  var directives = parseDirectives(lexer, true);
  var fields = parseFieldsDefinition(lexer);
  return {
    kind: Kind.OBJECT_TYPE_DEFINITION,
    description:description, /* ESIOK: stupid inferred key name */
    name:name, /* ESIOK: stupid inferred key name */
    interfaces:interfaces, /* ESIOK: stupid inferred key name */
    directives:directives, /* ESIOK: stupid inferred key name */
    fields:fields, /* ESIOK: stupid inferred key name */
    loc: loc(lexer, start),
  };
}

/**
 * ImplementsInterfaces :
 *   - implements '&'? NamedType
 *   - ImplementsInterfaces & NamedType
 */
private function parseImplementsInterfaces(lexer: Lexer): Array<NamedTypeNode> {
  var types = [];
  if (expectOptionalKeyword(lexer, 'implements')) {
    // Optional leading ampersand
    expectOptionalToken(lexer, TokenKind.AMP);
    do {
      types.push(parseNamedType(lexer));
    } while (
      expectOptionalToken(lexer, TokenKind.AMP) ||
      // Legacy support for the SDL?
      (lexer.options.allowLegacySDLImplementsInterfaces &&
        peek(lexer, TokenKind.NAME))
    );
  }
  return types;
}

/**
 * FieldsDefinition : { FieldDefinition+ }
 */
private function parseFieldsDefinition(lexer: Lexer): Array<FieldDefinitionNode> {
  // Legacy support for the SDL?
  if (
    lexer.options.allowLegacySDLEmptyFields &&
    peek(lexer, TokenKind.BRACE_L) &&
    lexer.lookahead().kind == TokenKind.BRACE_R
  ) {
    lexer.advance();
    lexer.advance();
    return [];
  }
  return peek(lexer, TokenKind.BRACE_L)
    ? many(lexer, TokenKind.BRACE_L, parseFieldDefinition, TokenKind.BRACE_R)
    : [];
}

/**
 * FieldDefinition :
 *   - Description? Name ArgumentsDefinition? : Type Directives[Const]?
 */
private function parseFieldDefinition(lexer: Lexer): FieldDefinitionNode {
  var start = lexer.token;
  var description = parseDescription(lexer);
  var name = parseName(lexer);
  var args = parseArgumentDefs(lexer);
  expectToken(lexer, TokenKind.COLON);
  var type = parseTypeReference(lexer);
  var directives = parseDirectives(lexer, true);
  return {
    kind: Kind.FIELD_DEFINITION,
    description:description, /* ESIOK: stupid inferred key name */
    name:name, /* ESIOK: stupid inferred key name */
    arguments: args,
    type:type, /* ESIOK: stupid inferred key name */
    directives:directives, /* ESIOK: stupid inferred key name */
    loc: loc(lexer, start),
  };
}

/**
 * ArgumentsDefinition : ( InputValueDefinition+ )
 */
private function parseArgumentDefs(lexer: Lexer): Array<InputValueDefinitionNode> {
  if (!peek(lexer, TokenKind.PAREN_L)) {
    return [];
  }
  return many(lexer, TokenKind.PAREN_L, parseInputValueDef, TokenKind.PAREN_R);
}

/**
 * InputValueDefinition :
 *   - Description? Name : Type DefaultValue? Directives[Const]?
 */
private function parseInputValueDef(lexer: Lexer): InputValueDefinitionNode {
  var start = lexer.token;
  var description = parseDescription(lexer);
  var name = parseName(lexer);
  expectToken(lexer, TokenKind.COLON);
  var type = parseTypeReference(lexer);
  var defaultValue=null /* INIT */;
  if (expectOptionalToken(lexer, TokenKind.EQUALS)) {
    defaultValue = parseConstValue(lexer);
  }
  var directives = parseDirectives(lexer, true);
  return {
    kind: Kind.INPUT_VALUE_DEFINITION,
    description:description, /* ESIOK: stupid inferred key name */
    name:name, /* ESIOK: stupid inferred key name */
    type:type, /* ESIOK: stupid inferred key name */
    defaultValue:defaultValue, /* ESIOK: stupid inferred key name */
    directives:directives, /* ESIOK: stupid inferred key name */
    loc: loc(lexer, start),
  };
}

/**
 * InterfaceTypeDefinition :
 *   - Description? interface Name Directives[Const]? FieldsDefinition?
 */
private function parseInterfaceTypeDefinition(
  lexer: Lexer): InterfaceTypeDefinitionNode 
{
  var start = lexer.token;
  var description = parseDescription(lexer);
  expectKeyword(lexer, 'interface');
  var name = parseName(lexer);
  var interfaces = parseImplementsInterfaces(lexer); // Re #48 - interfaces can implement interfaces
  var directives = parseDirectives(lexer, true);
  var fields = parseFieldsDefinition(lexer);
  return {
    kind: Kind.INTERFACE_TYPE_DEFINITION,
    description:description, /* ESIOK: stupid inferred key name */
    name:name, /* ESIOK: stupid inferred key name */
    directives:directives, /* ESIOK: stupid inferred key name */
    fields:fields, /* ESIOK: stupid inferred key name */
    loc: loc(lexer, start),
  };
}

/**
 * UnionTypeDefinition :
 *   - Description? union Name Directives[Const]? UnionMemberTypes?
 */
private function parseUnionTypeDefinition(lexer: Lexer): UnionTypeDefinitionNode {
  var start = lexer.token;
  var description = parseDescription(lexer);
  expectKeyword(lexer, 'union');
  var name = parseName(lexer);
  var directives = parseDirectives(lexer, true);
  var types = parseUnionMemberTypes(lexer);
  return {
    kind: Kind.UNION_TYPE_DEFINITION,
    description:description, /* ESIOK: stupid inferred key name */
    name:name, /* ESIOK: stupid inferred key name */
    directives:directives, /* ESIOK: stupid inferred key name */
    types:types, /* ESIOK: stupid inferred key name */
    loc: loc(lexer, start),
  };
}

/**
 * UnionMemberTypes :
 *   - = '|'? NamedType
 *   - UnionMemberTypes | NamedType
 */
private function parseUnionMemberTypes(lexer: Lexer): Array<NamedTypeNode> {
  var types = [];
  if (expectOptionalToken(lexer, TokenKind.EQUALS)) {
    // Optional leading pipe
    expectOptionalToken(lexer, TokenKind.PIPE);
    do {
      types.push(parseNamedType(lexer));
    } while (expectOptionalToken(lexer, TokenKind.PIPE));
  }
  return types;
}

/**
 * EnumTypeDefinition :
 *   - Description? enum Name Directives[Const]? EnumValuesDefinition?
 */
private function parseEnumTypeDefinition(lexer: Lexer): EnumTypeDefinitionNode {
  var start = lexer.token;
  var description = parseDescription(lexer);
  expectKeyword(lexer, 'enum');
  var name = parseName(lexer);
  var directives = parseDirectives(lexer, true);
  var values = parseEnumValuesDefinition(lexer);
  return {
    kind: Kind.ENUM_TYPE_DEFINITION,
    description:description, /* ESIOK: stupid inferred key name */
    name:name, /* ESIOK: stupid inferred key name */
    directives:directives, /* ESIOK: stupid inferred key name */
    values:values, /* ESIOK: stupid inferred key name */
    loc: loc(lexer, start),
  };
}

/**
 * EnumValuesDefinition : { EnumValueDefinition+ }
 */
private function parseEnumValuesDefinition(
  lexer: Lexer): Array<EnumValueDefinitionNode> 
{
  return peek(lexer, TokenKind.BRACE_L)
    ? many(
        lexer,
        TokenKind.BRACE_L,
        parseEnumValueDefinition,
        TokenKind.BRACE_R): [];
}

/**
 * EnumValueDefinition : Description? EnumValue Directives[Const]?
 *
 * EnumValue : Name
 */
private function parseEnumValueDefinition(lexer: Lexer): EnumValueDefinitionNode {
  var start = lexer.token;
  var description = parseDescription(lexer);
  var name = parseName(lexer);
  var directives = parseDirectives(lexer, true);
  return {
    kind: Kind.ENUM_VALUE_DEFINITION,
    description:description, /* ESIOK: stupid inferred key name */
    name:name, /* ESIOK: stupid inferred key name */
    directives:directives, /* ESIOK: stupid inferred key name */
    loc: loc(lexer, start),
  };
}

/**
 * InputObjectTypeDefinition :
 *   - Description? input Name Directives[Const]? InputFieldsDefinition?
 */
private function parseInputObjectTypeDefinition(
  lexer: Lexer): InputObjectTypeDefinitionNode 
{
  var start = lexer.token;
  var description = parseDescription(lexer);
  expectKeyword(lexer, 'input');
  var name = parseName(lexer);
  var directives = parseDirectives(lexer, true);
  var fields = parseInputFieldsDefinition(lexer);
  return {
    kind: Kind.INPUT_OBJECT_TYPE_DEFINITION,
    description:description, /* ESIOK: stupid inferred key name */
    name:name, /* ESIOK: stupid inferred key name */
    directives:directives, /* ESIOK: stupid inferred key name */
    fields:fields, /* ESIOK: stupid inferred key name */
    loc: loc(lexer, start),
  };
}

/**
 * InputFieldsDefinition : { InputValueDefinition+ }
 */
private function parseInputFieldsDefinition(
  lexer: Lexer): Array<InputValueDefinitionNode> 
{
  return peek(lexer, TokenKind.BRACE_L)
    ? many(lexer, TokenKind.BRACE_L, parseInputValueDef, TokenKind.BRACE_R)
    : [];
}

/**
 * TypeSystemExtension :
 *   - SchemaExtension
 *   - TypeExtension
 *
 * TypeExtension :
 *   - ScalarTypeExtension
 *   - ObjectTypeExtension
 *   - InterfaceTypeExtension
 *   - UnionTypeExtension
 *   - EnumTypeExtension
 *   - InputObjectTypeDefinition
 */
private function parseTypeSystemExtension(lexer: Lexer): TypeSystemExtensionNode {
  var keywordToken = lexer.lookahead();

  if (keywordToken.kind == TokenKind.NAME) {
    switch (keywordToken.value) {
      case 'schema':
        return parseSchemaExtension(lexer);
      case 'scalar':
        return parseScalarTypeExtension(lexer);
      case 'type':
        return parseObjectTypeExtension(lexer);
      case 'interface':
        return parseInterfaceTypeExtension(lexer);
      case 'union':
        return parseUnionTypeExtension(lexer);
      case 'enum':
        return parseEnumTypeExtension(lexer);
      case 'input':
        return parseInputObjectTypeExtension(lexer);
    }
  }

  throw unexpected(lexer, keywordToken);
}

/**
 * SchemaExtension :
 *  - extend schema Directives[Const]? { OperationTypeDefinition+ }
 *  - extend schema Directives[Const]
 */
private function parseSchemaExtension(lexer: Lexer): SchemaExtensionNode {
  var start = lexer.token;
  expectKeyword(lexer, 'extend');
  expectKeyword(lexer, 'schema');
  var directives = parseDirectives(lexer, true);
  var operationTypes = peek(lexer, TokenKind.BRACE_L)
    ? many(
        lexer,
        TokenKind.BRACE_L,
        parseOperationTypeDefinition,
        TokenKind.BRACE_R): [];
  if (directives.length == 0 && operationTypes.length == 0) {
    throw unexpected(lexer);
  }
  return {
    kind: Kind.SCHEMA_EXTENSION,
    directives:directives, /* ESIOK: stupid inferred key name */
    operationTypes:operationTypes, /* ESIOK: stupid inferred key name */
    loc: loc(lexer, start),
  };
}

/**
 * ScalarTypeExtension :
 *   - extend scalar Name Directives[Const]
 */
private function parseScalarTypeExtension(lexer: Lexer): ScalarTypeExtensionNode {
  var start = lexer.token;
  expectKeyword(lexer, 'extend');
  expectKeyword(lexer, 'scalar');
  var name = parseName(lexer);
  var directives = parseDirectives(lexer, true);
  if (directives.length == 0) {
    throw unexpected(lexer);
  }
  return {
    kind: Kind.SCALAR_TYPE_EXTENSION,
    name:name, /* ESIOK: stupid inferred key name */
    directives:directives, /* ESIOK: stupid inferred key name */
    loc: loc(lexer, start),
  };
}

/**
 * ObjectTypeExtension :
 *  - extend type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition
 *  - extend type Name ImplementsInterfaces? Directives[Const]
 *  - extend type Name ImplementsInterfaces
 */
private function parseObjectTypeExtension(lexer: Lexer): ObjectTypeExtensionNode {
  var start = lexer.token;
  expectKeyword(lexer, 'extend');
  expectKeyword(lexer, 'type');
  var name = parseName(lexer);
  var interfaces = parseImplementsInterfaces(lexer);
  var directives = parseDirectives(lexer, true);
  var fields = parseFieldsDefinition(lexer);
  if (
    interfaces.length == 0 &&
    directives.length == 0 &&
    fields.length == 0
  ) {
    throw unexpected(lexer);
  }
  return {
    kind: Kind.OBJECT_TYPE_EXTENSION,
    name:name, /* ESIOK: stupid inferred key name */
    interfaces:interfaces, /* ESIOK: stupid inferred key name */
    directives:directives, /* ESIOK: stupid inferred key name */
    fields:fields, /* ESIOK: stupid inferred key name */
    loc: loc(lexer, start),
  };
}

/**
 * InterfaceTypeExtension :
 *   - extend interface Name Directives[Const]? FieldsDefinition
 *   - extend interface Name Directives[Const]
 */
private function parseInterfaceTypeExtension(
  lexer: Lexer): InterfaceTypeExtensionNode 
{
  var start = lexer.token;
  expectKeyword(lexer, 'extend');
  expectKeyword(lexer, 'interface');
  var name = parseName(lexer);
  var directives = parseDirectives(lexer, true);
  var fields = parseFieldsDefinition(lexer);
  if (directives.length == 0 && fields.length == 0) {
    throw unexpected(lexer);
  }
  return {
    kind: Kind.INTERFACE_TYPE_EXTENSION,
    name:name, /* ESIOK: stupid inferred key name */
    directives:directives, /* ESIOK: stupid inferred key name */
    fields:fields, /* ESIOK: stupid inferred key name */
    loc: loc(lexer, start),
  };
}

/**
 * UnionTypeExtension :
 *   - extend union Name Directives[Const]? UnionMemberTypes
 *   - extend union Name Directives[Const]
 */
private function parseUnionTypeExtension(lexer: Lexer): UnionTypeExtensionNode {
  var start = lexer.token;
  expectKeyword(lexer, 'extend');
  expectKeyword(lexer, 'union');
  var name = parseName(lexer);
  var directives = parseDirectives(lexer, true);
  var types = parseUnionMemberTypes(lexer);
  if (directives.length == 0 && types.length == 0) {
    throw unexpected(lexer);
  }
  return {
    kind: Kind.UNION_TYPE_EXTENSION,
    name:name, /* ESIOK: stupid inferred key name */
    directives:directives, /* ESIOK: stupid inferred key name */
    types:types, /* ESIOK: stupid inferred key name */
    loc: loc(lexer, start),
  };
}

/**
 * EnumTypeExtension :
 *   - extend enum Name Directives[Const]? EnumValuesDefinition
 *   - extend enum Name Directives[Const]
 */
private function parseEnumTypeExtension(lexer: Lexer): EnumTypeExtensionNode {
  var start = lexer.token;
  expectKeyword(lexer, 'extend');
  expectKeyword(lexer, 'enum');
  var name = parseName(lexer);
  var directives = parseDirectives(lexer, true);
  var values = parseEnumValuesDefinition(lexer);
  if (directives.length == 0 && values.length == 0) {
    throw unexpected(lexer);
  }
  return {
    kind: Kind.ENUM_TYPE_EXTENSION,
    name:name, /* ESIOK: stupid inferred key name */
    directives:directives, /* ESIOK: stupid inferred key name */
    values:values, /* ESIOK: stupid inferred key name */
    loc: loc(lexer, start),
  };
}

/**
 * InputObjectTypeExtension :
 *   - extend input Name Directives[Const]? InputFieldsDefinition
 *   - extend input Name Directives[Const]
 */
private function parseInputObjectTypeExtension(
  lexer: Lexer): InputObjectTypeExtensionNode 
{
  var start = lexer.token;
  expectKeyword(lexer, 'extend');
  expectKeyword(lexer, 'input');
  var name = parseName(lexer);
  var directives = parseDirectives(lexer, true);
  var fields = parseInputFieldsDefinition(lexer);
  if (directives.length == 0 && fields.length == 0) {
    throw unexpected(lexer);
  }
  return {
    kind: Kind.INPUT_OBJECT_TYPE_EXTENSION,
    name:name, /* ESIOK: stupid inferred key name */
    directives:directives, /* ESIOK: stupid inferred key name */
    fields:fields, /* ESIOK: stupid inferred key name */
    loc: loc(lexer, start),
  };
}

/**
 * DirectiveDefinition :
 *   - Description? directive @ Name ArgumentsDefinition? on DirectiveLocations
 */
private function parseDirectiveDefinition(lexer: Lexer): DirectiveDefinitionNode {
  var start = lexer.token;
  var description = parseDescription(lexer);
  expectKeyword(lexer, 'directive');
  expectToken(lexer, TokenKind.AT);
  var name = parseName(lexer);
  var args = parseArgumentDefs(lexer);
  expectKeyword(lexer, 'on');
  var locations = parseDirectiveLocations(lexer);
  return {
    kind: Kind.DIRECTIVE_DEFINITION,
    description:description, /* ESIOK: stupid inferred key name */
    name:name, /* ESIOK: stupid inferred key name */
    arguments: args,
    locations:locations, /* ESIOK: stupid inferred key name */
    loc: loc(lexer, start),
  };
}

/**
 * DirectiveLocations :
 *   - '|'? DirectiveLocation
 *   - DirectiveLocations | DirectiveLocation
 */
private function parseDirectiveLocations(lexer: Lexer): Array<NameNode> {
  // Optional leading pipe
  expectOptionalToken(lexer, TokenKind.PIPE);
  var locations = [];
  do {
    locations.push(parseDirectiveLocation(lexer));
  } while (expectOptionalToken(lexer, TokenKind.PIPE));
  return locations;
}

/*
 * DirectiveLocation :
 *   - ExecutableDirectiveLocation
 *   - TypeSystemDirectiveLocation
 *
 * ExecutableDirectiveLocation : one of
 *   'QUERY'
 *   'MUTATION'
 *   'SUBSCRIPTION'
 *   'FIELD'
 *   'FRAGMENT_DEFINITION'
 *   'FRAGMENT_SPREAD'
 *   'INLINE_FRAGMENT'
 *
 * TypeSystemDirectiveLocation : one of
 *   'SCHEMA'
 *   'SCALAR'
 *   'OBJECT'
 *   'FIELD_DEFINITION'
 *   'ARGUMENT_DEFINITION'
 *   'INTERFACE'
 *   'UNION'
 *   'ENUM'
 *   'ENUM_VALUE'
 *   'INPUT_OBJECT'
 *   'INPUT_FIELD_DEFINITION'
 */
private function parseDirectiveLocation(lexer: Lexer): NameNode {
  var start = lexer.token;
  var name = parseName(lexer);
  if (ValidDirectiveLocations.get(name.value)) {
    return name;
  }
  throw unexpected(lexer, start);
}

// Core parsing utility functions

/**
 * Returns a location object, used to identify the place in
 * the source that created a given parsed object.
 */
/* class / function Loc() removed */

/**
 * Determines if the next token is of a given kind
 */
private function peek(lexer: Lexer, kind: TokenKindEnum):Bool {
  return lexer.token.kind == kind;
}

/**
 * If the next token is of the given kind, return that token after advancing
 * the lexer. Otherwise, do not change the parser state and throw an error.
 */
private function expectToken(lexer: Lexer, kind: TokenKindEnum): Token {
  var token = lexer.token;
  if (token.kind == kind) {
    lexer.advance();
    return token;
  }

  throw syntaxError(lexer.source, lexer.line, lexer.lineStart,
    token.start,
    'Expected ${kind}, found ${getTokenDesc(token)}');
}

/**
 * If the next token is of the given kind, return that token after advancing
 * the lexer. Otherwise, do not change the parser state and return null/* undefined
 */
private function expectOptionalToken(lexer: Lexer, kind: TokenKindEnum):Bool{
  var token = lexer.token;
  if (token.kind == kind) {
    lexer.advance();
    return token!=null;
  }
  return false/* undefined */;
}

/**
 * If the next token is a given keyword, return that token after advancing
 * the lexer. Otherwise, do not change the parser state and throw an error.
 */
private function expectKeyword(lexer: Lexer, value:String): Token {
  var token = lexer.token;
  if (token.kind == TokenKind.NAME && token.value == value) {
    lexer.advance();
    return token;
  }

  throw syntaxError(lexer.source, lexer.line, lexer.lineStart,
    token.start,
    'Expected "${value}", found ${getTokenDesc(token)}');
}

/**
 * If the next token is a given keyword, return that token after advancing
 * the lexer. Otherwise, do not change the parser state and return null/* undefined
 */
private function expectOptionalKeyword(lexer: Lexer, value:String):Bool{
  var token = lexer.token;
  if (token.kind == TokenKind.NAME && token.value == value) {
    lexer.advance();
    return token!=null;
  }
  return false/* undefined */;
}

/**
 * Helper function for creating an error when an unexpected lexed token
 * is encountered.
 */
private function unexpected(lexer: Lexer, ?atToken /* opt */ :Token): GraphQLError {
  var token = atToken!=null ? atToken : lexer.token;
  return syntaxError(lexer.source, lexer.line, lexer.lineStart,
    token.start,
    'Unexpected ${getTokenDesc(token)}');
}

/**
 * Returns a possibly empty list of parse nodes, determined by
 * the parseFn. This list begins with a lex token of openKind
 * and ends with a lex token of closeKind. Advances the parser
 * to the next lex token after the closing token.
 */
private function any<T>(
  lexer: Lexer,
  openKind: TokenKindEnum,
  parseFn: Lexer->T,
  closeKind: TokenKindEnum): Array<T> 
{
  expectToken(lexer, openKind);
  var nodes = [];
  while (!expectOptionalToken(lexer, closeKind)) {
    nodes.push(parseFn(lexer));
  }
  return nodes;
}

/**
 * Returns a non-empty list of parse nodes, determined by
 * the parseFn. This list begins with a lex token of openKind
 * and ends with a lex token of closeKind. Advances the parser
 * to the next lex token after the closing token.
 */
private function many<T>(
  lexer: Lexer,
  openKind: TokenKindEnum,
  parseFn: Lexer->T,
  closeKind: TokenKindEnum): Array<T> {
  expectToken(lexer, openKind);
  var nodes = [parseFn(lexer)];
  while (!expectOptionalToken(lexer, closeKind)) {
    nodes.push(parseFn(lexer));
  }
  return nodes;
}


private function loc(lexer: Lexer, startToken: Token): Location /* | void */ {
  if (lexer.options!=null && lexer.options.noLocation) return null;
  return { start:startToken.start, end:lexer.lastToken.end, startToken:startToken, endToken:lexer.lastToken, source:lexer.source };
}

private function syntaxError(source:Source, line:Int, lineStart:Int, start:Int, msg:String): GraphQLError {
  return graphql.parser.Parser.syntaxError(source, line, lineStart, start, msg);
}

private function getTokenDesc(t:Token) return t.kind;

  static var ValidDirectiveLocations:haxe.ds.StringMap<Bool> = [

  // Request Definitions
   'QUERY' => true,
   'MUTATION' => true,
   'SUBSCRIPTION' => true,
   'FIELD' => true,
   'FRAGMENT_DEFINITION' => true,
   'FRAGMENT_SPREAD' => true,
   'INLINE_FRAGMENT' => true,

  // Type System Definitions
   'SCHEMA' => true,
   'SCALAR' => true,
   'OBJECT' => true,
   'FIELD_DEFINITION' => true,
   'ARGUMENT_DEFINITION' => true,
   'INTERFACE' => true,
   'UNION' => true,
   'ENUM' => true,
   'ENUM_VALUE' => true,
   'INPUT_OBJECT' => true,
   'INPUT_FIELD_DEFINITION' => true
  ];

} // end of class GeneratedParser

